---
title: "Referencing records"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Referencing records}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Cross references

All GEDCOM records are given unique identifiers known as xrefs (cross-references) to allow other records to link to them. These are alphanumeric strings surrounded by '@' symbols. The `tidyged` package creates these xrefs automatically:

```{r}
library(tidyged)

simpsons <- gedcom(subm("Me")) %>% 
  add_indi(sex = "M") %>% 
  add_indi_names(name_pieces(given = "Homer", surname = "Simpson")) %>% 
  add_indi(sex = "F") %>% 
  add_indi_names(name_pieces(given = "Marge", surname = "Simpson")) %>% 
  add_indi(sex = "F") %>% 
  add_indi_names(name_pieces(given = "Lisa", surname = "Simpson")) %>% 
  add_indi(sex = "M") %>%  
  add_indi_names(name_pieces(given = "Bart", surname = "Simpson")) %>% 
  add_note("This is a note")

dplyr::filter(simpsons, tag %in% c("INDI", "NOTE")) %>% 
  knitr::kable()
```

Note the unique xrefs in the record column.

## Activation

In the above example a series of records are created (which will be explained in more detail in the proceeding articles). After each record is created, the name(s) of the individual are defined without actually explicitly referencing the Individual record. This is because they are acting on the *active record*. A record becomes active when it is created or when it is explicitly activated.

We can query the active record using the `get_active_record()` function:

```{r}
get_active_record(simpsons)
```

Since the last record to be created was the Note record, it is the active record. The active record is stored as an attribute of the tibble.

We can use activation to add to existing records. If we want to activate another record, we can activate it using the `activate_*()` family of functions together with its xref:

```{r}
simpsons %>% 
  activate_indi("@I2@") %>% 
  get_active_record()
```

## Finding cross reference identifiers

There are many other functions in the `gedcompendium` that take record xrefs as input parameters and it can be tedious to have to manually look these up. The `tidyged` package offers a number of helper functions to locate specific xrefs using pattern matching:

```{r}
find_indi_name(simpsons, "Bart")
find_indi_name_all(simpsons, "Simpson")
```

These helper functions begin with `find_*` and act as wrappers to the more general function `find_xref()`. It's straightforward to write your own wrapper if you're familiar with the tags used in the GEDCOM specification.

In the activation example, we would activate Marge's record with:

```{r}
simpsons %>% 
  activate_indi(find_indi_name(., "Marge")) %>% 
  get_active_record()
```

Note that the full name does not need to be given, since the term is partially matched. As long as it is detected in the name of the individual it will be found.

In this use case, if no match or more than one match is found, it will result in an error:

```{r, error = TRUE}
simpsons %>% 
  activate_indi(find_indi_name(., "Simpon")) %>% 
  get_active_record()
```

```{r, error = TRUE}
simpsons %>% 
  activate_indi(find_indi_name(., "Simpson")) %>% 
  get_active_record()
```

## Removing records

When removing entire records, you don't have to necessarily rely on activating them first. The same referencing techniques above can be used to remove records immediately:

```{r}
simpsons %>% 
  remove_indi(find_indi_name(., "Homer")) %>% 
  df_indi() %>% 
  knitr::kable()
```

## A note about unique record identifiers

Record identifiers have been a topic of much discussion in the GEDCOM user community. Even though xref identifiers will be imported unchanged in the `tidyged` package, some systems do create their own xref identifiers on import. So you cannot assume they will survive between systems. However, they should always be internally consistent.

A couple of other mechanisms exist for providing unique identifiers to records:

* An automated record identifier (RIN) can be used by a system to automatically assign a unique identifier. Since the most obvious way of generating this would be to base it on the xref, it would introduce unnecessary duplication and file bloat and so the `tidyged` package does not use this, nor expose it to a user;
* A user-defined reference number (REFN) and type can be defined by a user to uniquely identify a record. These are entirely optional, do not necessarily have to be unique, and a single record could have several defined. They are however a possible way of creating an enduring identifier between systems. Helper functions exist to locate xrefs using this number (`find_*_refn()`).

For these reasons, neither of these mechanisms are considered to be a better alternative way of selecting records.

<p style="text-align: right;"><a href="https://jl5000.github.io/tidyged/articles/individual_records.html">Next article: Individual records ></a></p>