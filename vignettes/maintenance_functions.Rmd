---
title: "Maintenance functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Maintenance functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

GEDCOM files can get very large and unwieldy, resulting in inefficiencies and file bloat. The `tidyged` package offers functions to automate the cleaning of GEDCOM files.

## Change dates

All top level records in a GEDCOM file can record the date and time they were last modified. The `tidyged` package includes change dates (today's date) by default every time a record is created or modified. Since the time is very unlikely to be useful in such a context, the package ignores this by default:

```{r}
library(tidyged)

gedcom(subm("Me")) %>% 
  print(n = Inf)
```

See row `r which(gedcom(subm("Me"))$tag == "CHAN")` and the row after for the change date for the submitter record.

By default this behaviour also applies when modifying existing records. If you would like to leave the change date alone when modifying a record, you can set `update_date_changed = FALSE` (it is TRUE by default).

For GEDCOM files with thousands of records, including change dates can add considerable bloat. For this reason it is possible to remove all change date structures with the `remove_change_dates()` function:

```{r}
gedcom(subm("Me")) %>% 
  remove_change_dates() %>% 
  print(n = Inf)
```

## Duplicate notes

With all records and many subrecords, it's possible to include custom notes to augment the information provided. These can either be the notes themselves, or a pointer to a top level Note record:

```{r}
notes <- gedcom(subm("Me")) %>%
  add_note("This is a generic note.") %>% 
  add_individual(individual_notes = c("This is a bespoke note.", "This is a generic note.")) %>% 
  add_repository("My repository", repository_notes = c("This is a bespoke note.", "This is a generic note."))

print(notes, n = Inf)
```

In the above example, there is a generic note recorded in a top level Note record. This same note message has been used for the individual and repository defined, but they have been repeated rather than pointing to the Note record. There is also a repeated bespoke note given in the Individual and Repository records.

The `consolidate_notes()` function will simplify the file, replacing note values with pointers to top level Note records (creating them if necessary) if they are repeated:

```{r}
consolidate_notes(notes) %>% print(n = Inf)
```

## Empty family groups

If there are any Family Group records with no references to Individual records, they can be removed automatically with the `remove_empty_family_groups()` function. In the function below we create 6 family group records, half with members, half without:

```{r}
gedcom(subm("Me")) %>% 
  add_individual() %>% 
  add_individual() %>% 
  add_individual() %>% 
  add_individual() %>% 
  add_family_group(husband = "@I1@", wife = "@I2@") %>% 
  add_family_group() %>% 
  add_family_group(husband = "@I4@") %>% 
  add_family_group() %>% 
  add_family_group(children = "@I3@") %>% 
  add_family_group() %>% 
  remove_empty_family_groups() %>%
  num_fam()
```

## Removing entire branches

One of the more sophisticated features of `tidyged` is the ability to delete entire branches of your tree. 

We illustrate its functionality using the family below consisting of three generations: A pair of parents who has a single child (named 'Person'). This person forms two separate family groups with two spouses, each resulting in two children.

```{r}
three_gen <- gedcom(subm("Me")) %>% 
  add_individual() %>% 
  add_individual_names("Parent /1/") %>% 
  add_individual() %>% 
  add_individual_names("Parent /2/") %>% 
  add_individual() %>% 
  add_individual_names("Person", given = "1") %>% 
  add_individual() %>% 
  add_individual_names("Spouse /1/") %>% 
  add_individual() %>% 
  add_individual_names("Spouse /2/") %>% 
  add_individual() %>% 
  add_individual_names("Child /1/") %>% 
  add_individual() %>% 
  add_individual_names("Child /2/") %>% 
  add_individual() %>% 
  add_individual_names("Child /3/") %>% 
  add_individual() %>% 
  add_individual_names("Child /4/") %>% 
  add_family_group("Parent 1", "Parent 2", children = "Person") %>% 
  add_family_group("Person", "Spouse 1", children = c("Child 1", "Child 2")) %>%
  add_family_group("Person", "Spouse 2", children = c("Child 3", "Child 4"))

df_families(three_gen) %>% knitr::kable()
```

We use the `remove_descendants()` function to specify whose descendants to remove. By default it will keep the individual and their spouses, and will remove all empty family groups:

```{r}
remove_descendants(three_gen, "Person") %>% 
  df_families() %>% 
  knitr::kable()
```

Setting `remove_spouses = TRUE` will remove all spouses and their descendants:

```{r}
remove_descendants(three_gen, "Person", remove_spouses = TRUE) %>% 
  df_families() %>% 
  knitr::kable()
```

Setting `remove_individual = TRUE` will remove the individual:

```{r}
remove_descendants(three_gen, "Person", remove_individual = TRUE) %>% 
  df_families() %>% 
  knitr::kable()
```

Setting both parameters to TRUE will remove both individuals. Since this will result in more empty families they will be removed:

```{r}
remove_descendants(three_gen, "Person", remove_individual = TRUE, remove_spouses = TRUE) %>% 
  df_families() %>% 
  knitr::kable()
```

Empty family groups can be retained by setting `remove_empty_families = FALSE`:

```{r}
remove_descendants(three_gen, "Person", remove_individual = TRUE, remove_spouses = TRUE,
                   remove_empty_families = FALSE) %>% 
  df_families() %>% 
  knitr::kable()
```

This function can result in the removal of a vast amount of data as it relies on recursive deletion. It will tell the user precisely what it is removing. Be sure the function has done what you expect before accepting the results. It is recommended that you use this function with extreme caution if you think a descendant (or their spouse) may be connected to an individual on another branch of your tree.
