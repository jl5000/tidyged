---
title: "Maintenance functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Maintenance functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

GEDCOM files can get very large and unwieldy, resulting in inefficiencies and file bloat. The `tidyged` package offers functions to automate the cleaning of GEDCOM files.

## Change dates

All top level records in a GEDCOM file can record the date and time they were last modified. The `tidyged` package includes change dates (today's date) by default every time a record is created or modified. Since the time is very unlikely to be useful in such a context, the package ignores this by default:

```{r}
library(tidyged)

gedcom(subm("Me")) %>% 
  print(n = Inf)
```

See row `r which(gedcom(subm("Me"))$tag == "CHAN")` and the row after for the change date for the submitter record.

By default this behaviour also applies when modifying existing records. If you would like to leave the change date alone when modifying a record, you can set `update_date_changed = FALSE` (it is TRUE by default).

For GEDCOM files with thousands of records, including change dates can add considerable bloat. For this reason it is possible to remove all change date structures with the `remove_change_dates()` function:

```{r}
gedcom(subm("Me")) %>% 
  remove_change_dates() %>% 
  print(n = Inf)
```

## Duplicate notes

With all records and many subrecords, it's possible to include custom notes to augment the information provided. These can either be the notes themselves, or a pointer to a top level Note record:

```{r}
notes <- gedcom(subm("Me")) %>%
  add_note("This is a generic note.") %>% 
  add_indi(indi_notes = c("This is a bespoke note.", "This is a generic note.")) %>% 
  add_repo("My repository", repo_notes = c("This is a bespoke note.", "This is a generic note."))

print(notes, n = Inf)
```

In the above example, there is a generic note recorded in a top level Note record. This same note message has been used for the individual and repository defined, but they have been repeated rather than pointing to the Note record. There is also a repeated bespoke note given in the Individual and Repository records.

The `consolidate_notes()` function will simplify the file, replacing note values with pointers to top level Note records (creating them if necessary) if they are repeated:

```{r}
consolidate_notes(notes) %>% print(n = Inf)
```

## Unreferenced records

If there are any records that are not referenced anywhere else, they can be found with the `identify_unused_records()` function. In the function below we create 6 family group records, half with members, half without, and also an unreferenced Repository record:

```{r}
some_unref <- gedcom(subm("Me")) %>% 
  add_indi("Tom /Smith/") %>% 
  add_indi("Tammy /Smith/") %>% 
  add_indi("Alice /White/") %>% 
  add_indi("Phil /Brown/") %>% 
  add_famg(husband = "Tom", wife = "Tammy") %>% 
  add_famg() %>% 
  add_famg(husband = "Phil") %>% 
  add_famg() %>% 
  add_famg(children = "Alice") %>% 
  add_famg() %>% 
  add_repo("Test repo") 
  
identify_unused_records(some_unref)
```

We can find out more about these xrefs by using the `describe_records()` function:

```{r}
identify_unused_records(some_unref) %>% 
  describe_records(gedcom = some_unref)
```

We can remove multiple records at once using the `remove_records()` function:

```{r}
remove_records(some_unref, identify_unused_records(some_unref)) %>% 
  str()
```


## Dealing with entire branches

One of the more sophisticated features of `tidyged` is the ability to manipulate entire branches of your tree. 

We illustrate its functionality using the family below consisting of three generations: A pair of parents who has a single child (named 'Main Person'). This person forms two separate family groups with two spouses, each resulting in two children.

```{r}
three_gen <- gedcom(subm("Me")) %>% 
  add_indi("Parent 1") %>% 
  add_indi("Parent 2") %>% 
  add_indi("Main Person") %>% 
  add_indi("Spouse 1") %>% 
  add_indi("Spouse 2") %>%
  add_indi("Child 1") %>% 
  add_indi("Child 2") %>% 
  add_indi("Child 3") %>% 
  add_indi("Child 4") %>% 
  add_famg("Parent 1", "Parent 2", children = "Main Person") %>% 
  add_famg("Main Person", "Spouse 1", children = c("Child 1", "Child 2")) %>%
  add_famg("Main Person", "Spouse 2", children = c("Child 3", "Child 4"))

df_famg(three_gen) %>% knitr::kable()
```

We use the `identify_descendants()` function below to identify the descendants of Main Person. By default it will exclude the individual and their spouses, and associated family groups:

```{r}
identify_descendants(three_gen, "Main Person")
```

We can use the `describe_records()` function to see descriptions:

```{r}
three_gen %>% 
  identify_descendants("Main Person") %>% 
  describe_records(three_gen, .)
```

Setting `include_spouses = TRUE` will include all spouses and their descendants:

```{r}
three_gen %>% 
  identify_descendants("Main Person", include_spouses = TRUE) %>% 
  describe_records(three_gen, .)
```

Setting `include_individual = TRUE` will include the individual:

```{r}
three_gen %>% 
  identify_descendants("Main Person", include_individual = TRUE) %>% 
  describe_records(three_gen, .)
```

Setting `include_families = TRUE` will include the individual's families where they are a spouse:

```{r}
three_gen %>% 
  identify_descendants("Main Person", include_individual = TRUE, include_spouses = TRUE,
                       include_families = TRUE) %>% 
  describe_records(three_gen, .)
```

Instead of describing the records, we can remove them with `remove_records()`:

```{r}
three_gen %>% 
  identify_descendants("Main Person", include_individual = TRUE, include_spouses = TRUE,
                       include_families = TRUE) %>% 
  remove_records(three_gen, .) %>% 
  df_famg() %>% 
  knitr::kable()
```

This combination can result in the removal of a vast amount of data. It will tell the user precisely what it is removing. Be sure the function has done what you expect before accepting the results. It is recommended that you use this function with extreme caution if you think a descendant (or their spouse) may be connected to an individual on another branch of your tree.

Instead of deleting the records, you can instead opt to create a new tidyged object with these records using the `split_gedcom()` function:

```{r}
three_gen %>% 
  identify_descendants("Main Person", include_individual = TRUE, include_spouses = TRUE,
                       include_families = TRUE) %>% 
  split_gedcom(three_gen, .) %>% 
  df_famg() %>% 
  knitr::kable()
```

This function will, by default, remove any dead references to records that have not been included in the subsetting.
